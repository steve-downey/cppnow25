<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Building Streams out of Hot Air</title>
<meta name="author" content="Steve Downey"/>
<meta name="description" content="
"/>
<meta name="keywords" content=" "/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="../etc/my_theme.css" id="theme"/>

<link rel="stylesheet" href="../etc/modus-vivendi-tinted.css"/>

<link rel="stylesheet" href="../etc/footer.css"/>
<link rel="stylesheet" type="text/css" href="../etc/modus-vivendi-tinted.css"/>
<link rel="stylesheet" type="text/css" href="../etc/modus-vivendi-tinted.css" />
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide" data-background="./title.png">
<p>
</section>
<section>
<section id="slide-orga76cb46" data-visibility="hidden">
<h2 id="orga76cb46">Code Test</h2>
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"hello, world\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Inline <code>code</code> and <code>verbatim</code>.
</p>

<p>
And export <code class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">(){}</span></code> in line as an inline block.
</p>
</section>
</section>
<section>
<section id="slide-org069dc19">
<h2 id="org069dc19" class="r-fit-text">Building sender streams out of senders</h2>
<p>
We're going to build an async stream, an infinite list, out of nothing but senders.
</p>

<p class="fragment (appear)">
Along the way we'll take a look at the last 80 years of computer science, including some areas of current active research.
</p>

<p class="fragment (appear)">
Having a better idea of how senders, and functions like them, are grounded in theory gives us a better idea of how they can be used and where to look to borrow designs and insights.
</p>

</section>
<section>
<blockquote>
<p>
We don't just borrow [syntax]; on occasion, [C++] has pursued other languages down alleyways to beat them unconscious and rifle their pockets for new [semantics].
</p>

<p>
&#x2014;(with apologies to) James D. Nicoll
</p>
</blockquote>

</section>
<section>
<blockquote>
<p>
I'm going to show you even a more horrible thing, a definition of CONS in terms of nothing but air, hot air.
</p>

<p>
&#x2014;Gerald Jay Sussman, Computational Objects
</p>
</blockquote>
<p>

<a href="https://ocw.mit.edu/courses/6-001-structure-and-interpretation-of-computer-programs-spring-2005/resources/5b-computational-objects/">Video Lectures - 5B: Computational Objects</a>
</p>
<aside class="notes">
<p>
C++ P2300 Senders are computations to be performed&#x2014;"an object that describes work".  (see <a href="#citeproc_bib_item_4">Niebler et al. 2024, 4.3</a>) Taking designs that suspend computation are a natural place to begin when planning senders. Models that do so in an otherwise strict evaluation environment can be easier to reason about for porting to C++ than from default lazy environments, such as Haskell.
</p>

<p>
By 'air' Sussman meant building a data structure out of nothing but higher order lambda expressions in <code>scheme</code>. The technique is also a common implementation technique for functional programming languages, and turns out to be one of the ways pattern matching is supported.
</p>

<p>
This can be implemented directly using C++ lambda, particularly easily now that recursive lambda is possible using <code>deducing this</code>. We start out by implementing <code>Either</code>, then <code>Pair</code>, <code>Maybe</code>, <code>Boolean</code>, and then see how recursive types can be made, such as a <code>cons</code> <code>list</code>. The core of the pattern is closely related to generalized <code>fold</code>, or <code>catamorphism</code>, and has deep connections with the <code>Visitor</code> pattern.
</p>

<p>
Changing perspective from inductive types, like <code>list</code> to coinductive, infinite, types, like <code>stream</code>, means looking at deconstruction, or observation, of <code>codata</code>. The pattern of dispatching to handlers remains the same, though, with some slight inversion.
</p>

<p>
This guides us to a concrete Sender design which can be implemented as concrete sender types, rather than wrapping unnamed higher order functions. This also helps avoid recursion in the type system, hiding the uninteresting intermediate types being sent. Also, this provides an excuse to  demonstrate implementing a sender. There are not enough examples, but writing a sender is intended to be within the scope of work for an intermediate C++ developer.
</p>

<p>
At the end we will have an async queue and an async stream implemented using just senders.
</p>

</aside>
</section>
</section>
<section>
<section id="slide-orge3bf3d1">
<h2 id="orge3bf3d1">Lambda expressions</h2>
<div class="outline-text-2" id="text-orge3bf3d1">
</div>
<ul class="org-ul">
<li><a id="orga9b51b4"></a>The core:<br />
<dl>
<dt><i>x</i></dt><dd>a variable.</dd>
<dt>&lambda; <i>x</i> . <i>M</i></dt><dd>a function of one variable with definition <i>M</i>.</dd>
<dt><i>M</i> <i>N</i></dt><dd>application of the function <i>M</i> to the argument <i>N</i>.</dd>

</dl>
</li>
<li><a id="org7ff2a20"></a>&Beta;-reduction:<br />
<ul>
<li>((&lambda; x . <i>M</i>) <i>N</i>) &rarr; (<i>M</i>[x:= /N/])</li>

</ul>
</li>
<li><a id="orgeb81ad2"></a>Notational Sugar<br />
<ul>
<li>Multi-variable extension
<ul>
<li>&lambda; x y . <i>M</i> &harr; &lambda; x . (&lambda; y . <i>M</i>)</li>

</ul></li>

</ul>
<p>
or
</p>
<ul>
<li>&lambda; x y . <i>M</i> &harr; &lambda; x . &lambda; y . <i>M</i></li>

</ul>
<ul>
<li>Currying
<ul>
<li>(f x y z) &harr; (((f x) y) z)</li>

</ul></li>

</ul>
</li>
</ul>
</section>
</section>
<section>
<section id="slide-orgdb02a4b">
<h2 id="orgdb02a4b">Closures</h2>
<dl>
<dt>Closure</dt><dd>A function that retains access to the names contained in the scope in which it was created.</dd>

</dl>
</section>
</section>
<section>
<section id="slide-orga08e38e">
<h2 id="orga08e38e">Higher Order Functions</h2>
<p>
Functions that can take or return functions.
</p>

<p>
Those might be closures.
</p>
</section>
</section>
<section>
<section id="slide-org0f2f71d">
<h2 id="org0f2f71d">Things Are What They Do</h2>
<div class="outline-text-2" id="text-org0f2f71d">
</div>
</section>
<section id="slide-orgcba044d">
<h3 id="orgcba044d">Either example with typeclass map</h3>
<div class="outline-text-3" id="text-orgcba044d">
</div>
</section>
<section id="slide-orgfff08ea">
<h4 id="orgfff08ea">Shape of typeclass map</h4>
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">E</span>, <span class="org-keyword">typename</span> <span class="org-type">L</span>, <span class="org-keyword">typename</span> <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">EitherTypeclass</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">left</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">L</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">E</span>;
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">right</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">R</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">E</span>;
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">isLeft</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">E</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">bool</span>;
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">isRight</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">E</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">bool</span>;
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">fromLeft</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">E</span>, <span class="org-type">L</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">L</span>;
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">fromRight</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">E</span>, <span class="org-type">L</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">L</span>;
        <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">either</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">E</span> <span class="org-variable-name">e</span>, <span class="org-type">invocable_r</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">C</span>, <span class="org-type">L</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">auto</span>,
                              <span class="org-type">invocable_r</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">C</span>, <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">auto</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">C</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
<section id="slide-org068af3e">
<h4 id="org068af3e">Either Typeclass for <code>std::expected</code></h4>
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">L</span>, <span class="org-keyword">typename</span> <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-keyword">struct</span> <span class="org-type">EitherTypeclass</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">expected</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">L</span>, <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>, <span class="org-type">L</span>, <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">using</span> <span class="org-type">E</span> = <span class="org-constant">std</span>::<span class="org-type">expected</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">L</span>, <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>;
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">left</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">L</span> <span class="org-variable-name">l</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">E</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> l; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">right</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">R</span> <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">E</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-constant">std</span>::unexpected<span class="org-rainbow-delimiters-depth-3">{</span>r<span class="org-rainbow-delimiters-depth-3">}</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">isLeft</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">E</span> <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> e.has_value<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">isRight</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">E</span> <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-keyword">not</span> e.has_value<span class="org-rainbow-delimiters-depth-3">()</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">fromLeft</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">E</span> <span class="org-variable-name">e</span>, <span class="org-type">L</span> <span class="org-variable-name">l</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">L</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> isLeft<span class="org-rainbow-delimiters-depth-3">(</span>e<span class="org-rainbow-delimiters-depth-3">)</span> ? e.value<span class="org-rainbow-delimiters-depth-3">()</span> : l;
        <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">fromRight</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">E</span> <span class="org-variable-name">e</span>, <span class="org-type">R</span> <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">R</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> isRight<span class="org-rainbow-delimiters-depth-3">(</span>e<span class="org-rainbow-delimiters-depth-3">)</span> ? e.error<span class="org-rainbow-delimiters-depth-3">()</span> : r;
        <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">either</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">E</span> <span class="org-variable-name">e</span>, <span class="org-type">invocable_r</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">C</span>, <span class="org-type">L</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">auto</span> <span class="org-variable-name">left</span>,
                              <span class="org-type">invocable_r</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">C</span>, <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">auto</span> <span class="org-variable-name">right</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">C</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> isLeft<span class="org-rainbow-delimiters-depth-3">(</span>e<span class="org-rainbow-delimiters-depth-3">)</span> ? left<span class="org-rainbow-delimiters-depth-3">(</span>e.value<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span> : right<span class="org-rainbow-delimiters-depth-3">(</span>e.error<span class="org-rainbow-delimiters-depth-4">()</span><span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
<section id="slide-orge38f95a">
<h4 id="orge38f95a">Test function and construction</h4>
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">Either</span>, <span class="org-keyword">typename</span> <span class="org-type">Left</span>, <span class="org-keyword">typename</span> <span class="org-type">Right</span>,
          <span class="org-keyword">auto</span> <span class="org-variable-name">either_map</span> = <span class="org-type">either_typeclass</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">Either</span>, <span class="org-type">Left</span>, <span class="org-type">Right</span><span class="org-rainbow-delimiters-depth-2">&gt;</span><span class="org-rainbow-delimiters-depth-1">&gt;</span>
<span class="org-type">void</span> <span class="org-function-name">test_function</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">l</span> = either_map.left<span class="org-rainbow-delimiters-depth-2">(</span>7<span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">r</span> = either_map.right<span class="org-rainbow-delimiters-depth-2">(</span>9.0<span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">b1</span> = either_map.isLeft<span class="org-rainbow-delimiters-depth-2">(</span>l<span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">b2</span> = either_map.isLeft<span class="org-rainbow-delimiters-depth-2">(</span>r<span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">b3</span> = either_map.isRight<span class="org-rainbow-delimiters-depth-2">(</span>l<span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-keyword">constexpr</span> <span class="org-type">bool</span> <span class="org-variable-name">b4</span> = either_map.isRight<span class="org-rainbow-delimiters-depth-2">(</span>r<span class="org-rainbow-delimiters-depth-2">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-2">(</span>b1 == <span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-2">(</span>b2 == <span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-2">(</span>b3 == <span class="org-constant">false</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-2">(</span>b4 == <span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-2">)</span>;
</pre>
</div>
</section>
<section id="slide-org2e2b8af">
<h4 id="org2e2b8af"><code>fromLeft</code> and <code>fromRight</code></h4>
<div class="org-src-container">

<pre class="src src-cpp">        <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">k1</span> = either_map.fromLeft<span class="org-rainbow-delimiters-depth-1">(</span>l, 11<span class="org-rainbow-delimiters-depth-1">)</span>;
        <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">k2</span> = either_map.fromLeft<span class="org-rainbow-delimiters-depth-1">(</span>r, 11<span class="org-rainbow-delimiters-depth-1">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-1">(</span>k1 == 7<span class="org-rainbow-delimiters-depth-1">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-1">(</span>k2 == 11<span class="org-rainbow-delimiters-depth-1">)</span>;

        <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">k3</span> = either_map.fromRight<span class="org-rainbow-delimiters-depth-1">(</span>l, 11<span class="org-rainbow-delimiters-depth-1">)</span>;
        <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">k4</span> = either_map.fromRight<span class="org-rainbow-delimiters-depth-1">(</span>r, 11<span class="org-rainbow-delimiters-depth-1">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-1">(</span>k3 == 11.0<span class="org-rainbow-delimiters-depth-1">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-1">(</span>k4 == 9.0<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>
</section>
<section id="slide-org5460580">
<h4 id="org5460580">Case switch</h4>
<div class="org-src-container">

<pre class="src src-cpp">        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">match</span> = <span class="org-rainbow-delimiters-depth-1">[</span>=<span class="org-rainbow-delimiters-depth-1">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
                <span class="org-keyword">return</span> either_map.<span class="org-keyword">template</span> either<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>
                        e, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">)</span> -&gt; <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> 2 * x; <span class="org-rainbow-delimiters-depth-3">}</span>,
                        <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">)</span> -&gt; <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> 3 * x; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-rainbow-delimiters-depth-1">}</span>;
        <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">d1</span> = match<span class="org-rainbow-delimiters-depth-1">(</span>l<span class="org-rainbow-delimiters-depth-1">)</span>;
        <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">d2</span> = match<span class="org-rainbow-delimiters-depth-1">(</span>r<span class="org-rainbow-delimiters-depth-1">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-1">(</span>d1 == 14.0<span class="org-rainbow-delimiters-depth-1">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-1">(</span>d2 == 27.0<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-rainbow-delimiters-unmatched">}</span>
</pre>
</div>
</section>
<section id="slide-org22cac2e">
<h4 id="org22cac2e">Calling the test function</h4>
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span> test_function<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">expected</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-type">int</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</section>
<section id="slide-org424f416">
<h3 id="org424f416">Pair example with typeclass map</h3>
<div class="outline-text-3" id="text-org424f416">
</div>
</section>
<section id="slide-org6f2ffc3">
<h4 id="org6f2ffc3">Shape of typeclass map</h4>
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">P</span>, <span class="org-keyword">typename</span> <span class="org-type">L</span>, <span class="org-keyword">typename</span> <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">PairTypeclass</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">pair</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">L</span>, <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">P</span>;
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">first</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">P</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">L</span>;
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">second</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">P</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">R</span>;
        <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">apply</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">P</span> <span class="org-variable-name">e</span>, <span class="org-type">invocable_r</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">C</span>, <span class="org-type">L</span>, <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">auto</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">C</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
<section id="slide-org3794561">
<h4 id="org3794561">Pair Typeclass for <code>std::pair</code></h4>
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">L</span>, <span class="org-keyword">typename</span> <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-keyword">struct</span> <span class="org-type">PairTypeclass</span><span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">pair</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">L</span>, <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>, <span class="org-type">L</span>, <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-1">&gt;</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">using</span> <span class="org-type">P</span> = <span class="org-constant">std</span>::<span class="org-type">pair</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">L</span>, <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>;
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">pair</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">L</span> <span class="org-variable-name">l</span>, <span class="org-type">R</span> <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">P</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">{</span>l, r<span class="org-rainbow-delimiters-depth-3">}</span>; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">first</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">P</span> <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">L</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> p.first; <span class="org-rainbow-delimiters-depth-2">}</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">second</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">P</span> <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">R</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> p.second; <span class="org-rainbow-delimiters-depth-2">}</span>

        <span class="org-keyword">template</span> <span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-keyword">typename</span> <span class="org-type">C</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-function-name">apply</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-type">P</span> <span class="org-variable-name">p</span>, <span class="org-type">invocable_r</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">C</span>, <span class="org-type">L</span>, <span class="org-type">R</span><span class="org-rainbow-delimiters-depth-3">&gt;</span> <span class="org-keyword">auto</span> <span class="org-variable-name">f</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-keyword">const</span> -&gt; <span class="org-type">C</span> <span class="org-rainbow-delimiters-depth-2">{</span>
                <span class="org-keyword">return</span> f<span class="org-rainbow-delimiters-depth-3">(</span>p.first, p.second<span class="org-rainbow-delimiters-depth-3">)</span>;
        <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
<section id="slide-org21885f1">
<h4 id="org21885f1">Test function and construction</h4>
<div class="org-src-container">

<pre class="src src-cpp">
        <span class="org-comment-delimiter">// </span><span class="org-comment">8a9dbcf7-cee4-474d-ab35-2d433f9a74fb</span>
        <span class="org-keyword">constexpr</span> <span class="org-type">int</span> <span class="org-variable-name">k1</span> = pair_map.first<span class="org-rainbow-delimiters-depth-1">(</span>p1<span class="org-rainbow-delimiters-depth-1">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-1">(</span>k1 == 7<span class="org-rainbow-delimiters-depth-1">)</span>;

        <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">k3</span> = pair_map.second<span class="org-rainbow-delimiters-depth-1">(</span>p1<span class="org-rainbow-delimiters-depth-1">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-1">(</span>k3 == 9.0<span class="org-rainbow-delimiters-depth-1">)</span>;
        <span class="org-comment-delimiter">// </span><span class="org-comment">8a9dbcf7-cee4-474d-ab35-2d433f9a74fb end</span>

        <span class="org-comment-delimiter">// </span><span class="org-comment">ef0d2d45-e59e-4d70-a5a7-933016d63238</span>
        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">match</span> = <span class="org-rainbow-delimiters-depth-1">[</span>=<span class="org-rainbow-delimiters-depth-1">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-1">{</span>
                <span class="org-keyword">return</span> pair_map.<span class="org-keyword">template</span> apply<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>
                        p, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-3">)</span> -&gt; <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-3">{</span>
                                <span class="org-keyword">return</span> 2 * x + 3 * y;
                        <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-rainbow-delimiters-depth-1">}</span>;
        <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">d1</span> = match<span class="org-rainbow-delimiters-depth-1">(</span>p1<span class="org-rainbow-delimiters-depth-1">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-1">(</span>d1 == 41.0<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-rainbow-delimiters-unmatched">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">ef0d2d45-e59e-4d70-a5a7-933016d63238 end</span>

<span class="org-comment-delimiter">// </span><span class="org-comment">9a1fd6e9-3ca8-4321-8b6c-7ad48256b9ed</span>
<span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-unmatched">()</span> <span class="org-rainbow-delimiters-unmatched">{</span> test_function<span class="org-rainbow-delimiters-depth-1">&lt;</span><span class="org-constant">std</span>::<span class="org-type">pair</span><span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;</span>, <span class="org-type">int</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-1">&gt;()</span>; <span class="org-rainbow-delimiters-unmatched">}</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">9a1fd6e9-3ca8-4321-8b6c-7ad48256b9ed end</span>
</pre>
</div>
</section>
<section id="slide-org6d73c81">
<h4 id="org6d73c81">Apply</h4>
<div class="org-src-container">

<pre class="src src-cpp">        <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">match</span> = <span class="org-rainbow-delimiters-depth-1">[</span>=<span class="org-rainbow-delimiters-depth-1">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-1">{</span>
                <span class="org-keyword">return</span> pair_map.<span class="org-keyword">template</span> apply<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;(</span>
                        p, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">y</span><span class="org-rainbow-delimiters-depth-3">)</span> -&gt; <span class="org-type">double</span> <span class="org-rainbow-delimiters-depth-3">{</span>
                                <span class="org-keyword">return</span> 2 * x + 3 * y;
                        <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
        <span class="org-rainbow-delimiters-depth-1">}</span>;
        <span class="org-keyword">constexpr</span> <span class="org-type">double</span> <span class="org-variable-name">d1</span> = match<span class="org-rainbow-delimiters-depth-1">(</span>p1<span class="org-rainbow-delimiters-depth-1">)</span>;
        static_assert<span class="org-rainbow-delimiters-depth-1">(</span>d1 == 41.0<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-rainbow-delimiters-unmatched">}</span>
</pre>
</div>
</section>
<section id="slide-orgdca26f9">
<h4 id="orgdca26f9">Calling the test function</h4>
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span> test_function<span class="org-rainbow-delimiters-depth-2">&lt;</span><span class="org-constant">std</span>::<span class="org-type">pair</span><span class="org-rainbow-delimiters-depth-3">&lt;</span><span class="org-type">int</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-3">&gt;</span>, <span class="org-type">int</span>, <span class="org-type">double</span><span class="org-rainbow-delimiters-depth-2">&gt;()</span>; <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</section>
</section>
<section>
<section id="slide-org19b3cb7">
<h2 id="org19b3cb7">Implementing Data with Lambda</h2>
<div class="outline-text-2" id="text-org19b3cb7">
</div>
</section>
<section id="slide-org785be41">
<h3 id="org785be41">Closures and Partial Application</h3>
<p>
Closures mean we can hold on to values.
</p>

<p>
Partial Application means we can defer using the values.
</p>

<ol>
<li>&lambda; x f. f x</li>
<li>(&lambda; x f. f x) a &rarr; &lambda; f. f a</li>
<li>((&lambda; x f. f x) a) g &rarr; g a</li>

</ol>
</section>
<section id="slide-org5eca548">
<h3 id="org5eca548">Continuation Passing Style</h3>
<p>
Pass functions to closures to defer what to do next.
</p>

<p>
Two main strategies for encoding:
</p>
<dl>
<dt>Church</dt><dd>the <i>folds</i> or <i>catamorphisms</i> for an ADT</dd>
<dt>Scott</dt><dd>the <i>pattern matching</i> or <i>visitor</i> for an ADT</dd>

</dl>
</section>
<section id="slide-org36cb659">
<h3 id="org36cb659">Recursive vs Non-recursive Types</h3>
<p>
For non-recursive types these are the same.
</p>

<p>
Either, Pair, Maybe, Boolean are non-recursive.
</p>

<p>
List is recursive.
</p>
</section>
<section id="slide-orgd281b6b">
<h3 id="orgd281b6b"><code>Either</code></h3>
<div class="outline-text-3" id="text-orgd281b6b">
</div>
</section>
<section id="slide-org429ff42">
<h4 id="org429ff42">Definition</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">data</span>  <span class="org-haskell-type">Either</span> a b
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Left</span> a
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Right</span> b
</pre>
</div>
</section>
<section id="slide-org5f93023">
<h4 id="org5f93023">Construction</h4>
<p>
<i>left</i>   = &lambda; a . &lambda; l r . l a
</p>

<p>
<i>right</i>  = &lambda; b . &lambda; l r . r b
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">left</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">a</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>a<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">l</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">[</span>l, a<span class="org-rainbow-delimiters-depth-3">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">_</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> l<span class="org-rainbow-delimiters-depth-4">(</span>a<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">right</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">b</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>b<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">_</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">[</span>b<span class="org-rainbow-delimiters-depth-3">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> r<span class="org-rainbow-delimiters-depth-4">(</span>b<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
<section id="slide-orgcb153b2">
<h4 id="orgcb153b2">Case Analysis</h4>
<p>
<i>either</i> = &lambda; l r e. e l r
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">either</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">l</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>l<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">[</span>l, r<span class="org-rainbow-delimiters-depth-3">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">e</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> e<span class="org-rainbow-delimiters-depth-4">(</span>l<span class="org-rainbow-delimiters-depth-4">)(</span>r<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
<section id="slide-orgbe97cbf">
<h3 id="orgbe97cbf"><code>Pair</code></h3>
<div class="outline-text-3" id="text-orgbe97cbf">
</div>
</section>
<section id="slide-org28ac362">
<h4 id="org28ac362">Definition</h4>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">data</span>  <span class="org-haskell-type">Pair</span> l r
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Pair</span> l r
</pre>
</div>
</section>
<section id="slide-orgfb7e438">
<h4 id="orgfb7e438">Construction</h4>
<p>
<i>pair</i> = &lambda; l r . &lambda; p. p l r
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">pair</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">l</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>l, r<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> p<span class="org-rainbow-delimiters-depth-3">(</span>l, r<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
<section id="slide-orgdf0335f">
<h4 id="orgdf0335f">Observation</h4>
<p>
<i>fst</i> = &lambda; p . p (&lambda; l r. l)
</p>

<p>
<i>snd</i> = &lambda; p . p (&lambda; l r. r)
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">fst</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> p<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">l</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> l; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">snd</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">p</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> p<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">l</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">r</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> r; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
<section id="slide-org1f5b291">
<h3 id="org1f5b291"><code>Maybe</code></h3>
<div class="outline-text-3" id="text-org1f5b291">
</div>
</section>
<section id="slide-orgcdc7802">
<h4 id="orgcdc7802">Definition</h4>
<div class="org-src-container">

<pre class="src src-haskell">    <span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Maybe</span> a
      <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nothing</span>
      <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Just</span> a
</pre>
</div>
</section>
<section id="slide-orgc8723e0">
<h4 id="orgc8723e0">Construction</h4>
<p>
<i>nothing</i> = &lambda; . &lambda; n . &lambda; j . n
</p>

<p>
<i>just</i> = &lambda; x . &lambda; n . &lambda; j . j x
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">nothing</span> = <span class="org-rainbow-delimiters-depth-1">[]()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">n</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">[</span>n<span class="org-rainbow-delimiters-depth-3">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">_</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> n<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">just</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>x<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">_</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">[</span>x<span class="org-rainbow-delimiters-depth-3">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">j</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> j<span class="org-rainbow-delimiters-depth-4">(</span>x<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
<section id="slide-org82b33ca">
<h4 id="org82b33ca">Observation</h4>
<p>
<i>isNothing</i> = &lambda; m . m (&lambda; . true) (&lambda; . false)
</p>

<p>
<i>isJust</i> = &lambda; m . m (&lambda; . false) (&lambda; . true)
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">isNothing</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">m</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> m<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[]()</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)(</span><span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">_</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">isJust</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">m</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> m<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[]()</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)(</span><span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">_</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
<span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">fromJust</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">m</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> m<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[]()</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-constant">std</span>::abort<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)(</span><span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> x; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
<section id="slide-orgd2c9951">
<h4 id="orgd2c9951">Case Analysis</h4>
<p>
<i>maybe</i>   = &lambda; n j m . m n j
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">maybe</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">d</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>d<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">f</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-3">[</span>d, f<span class="org-rainbow-delimiters-depth-3">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">m</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> m<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-rainbow-delimiters-depth-5">[</span><span class="org-constant">d</span><span class="org-rainbow-delimiters-depth-5">]()</span> <span class="org-rainbow-delimiters-depth-5">{</span> <span class="org-keyword">return</span> d; <span class="org-rainbow-delimiters-depth-5">}</span><span class="org-rainbow-delimiters-depth-4">)(</span>f<span class="org-rainbow-delimiters-depth-4">)</span>; <span class="org-rainbow-delimiters-depth-3">}</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
<section id="slide-orgd9701ec">
<h3 id="orgd9701ec"><code>List</code></h3>
<div class="org-src-container">

<pre class="src src-haskell">    <span class="org-haskell-keyword">data</span> <span class="org-haskell-type">List</span> a
      <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nil</span>
      <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Cons</span> a <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-haskell-constructor">List</span> a<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</section>
<section id="slide-orga3bef59">
<h4 id="orga3bef59">Construction</h4>
<p>
nil  =         λn c . n
cons = λx xs . λn c . c x xs
</p>
</section>
<section id="slide-orgb29c949">
<h4 id="orgb29c949">Church Encoding</h4>
<p>
<i>nil</i>  = &lambda; c n . n
</p>

<p>
<i>cons</i> = &lambda; x xs c n . c x (xs c n)
</p>
</section>
<section id="slide-orgb1f3378">
<h4 id="orgb1f3378">Scott Encoding</h4>
<p>
<i>nil</i>  = &lambda; c n . n
</p>

<p>
<i>cons</i> = &lambda; x xs c n . c x xs
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">Nil</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">nil</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">cons</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span> <span class="org-keyword">return</span> nil<span class="org-rainbow-delimiters-depth-2">()</span>; <span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">Cons</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> <span class="org-rainbow-delimiters-depth-2">[</span>x, xs<span class="org-rainbow-delimiters-depth-2">](</span><span class="org-keyword">auto</span> <span class="org-variable-name">nil</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">cons</span><span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span> <span class="org-keyword">return</span> cons<span class="org-rainbow-delimiters-depth-3">(</span>x, xs<span class="org-rainbow-delimiters-depth-3">)</span>; <span class="org-rainbow-delimiters-depth-2">}</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>
</section>
<section id="slide-org6a30c76">
<h4 id="org6a30c76">Observers</h4>
<p>
<i>isNil</i>  = \l . l (\x xs . false) true
</p>

<p>
<i>head</i>   = \l . l (\x xs . x) error
</p>
<ul class="org-ul">
<li><a id="org0453794"></a>Church<br />
<ul>
<li><i>length</i> = \l . l (\x xs . (+) xs) 0</li>
<li><i>tail</i>   = \l c n . l (\x xs g . g x (xs c)) (\xs . n) (\x xs . xs)</li>

</ul>

<p>
You are not expected to understand that.
</p>
</li>
<li><a id="org2fa5228"></a>Scott:<br />
<ul>
<li><i>length</i> = \l . l (\x xs . (+) (length xs)) 0</li>
<li><i>tail</i>   = \l . l (\x xs . xs) nil</li>

</ul>
</li>
</ul>
</section>
<section id="slide-orgb1bbe4a">
<h5 id="orgb1bbe4a">C++ Code for Scott List</h5>
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">isNil</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">l</span><span class="org-rainbow-delimiters-depth-1">)</span> -&gt; <span class="org-type">bool</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> l<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[]()</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">true</span>; <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">head</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">l</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> l<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[]()</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-constant">std</span>::abort<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> x; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;

<span class="org-keyword">inline</span> <span class="org-keyword">constexpr</span> <span class="org-keyword">auto</span> <span class="org-variable-name">tail</span> = <span class="org-rainbow-delimiters-depth-1">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">l</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
        <span class="org-keyword">return</span> l<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">[]()</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-constant">std</span>::abort<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>, <span class="org-rainbow-delimiters-depth-3">[](</span><span class="org-keyword">auto</span> <span class="org-variable-name">x</span>, <span class="org-keyword">auto</span> <span class="org-variable-name">xs</span><span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> xs; <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>;
</pre>
</div>

<aside class="notes">
<p>
<a href="https://hackage.haskell.org/package/gulcii-0.3/src/doc/encoding.md">https://hackage.haskell.org/package/gulcii-0.3/src/doc/encoding.md</a>
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org5ec37bd">
<h2 id="org5ec37bd">The Pattern(s)</h2>
<div class="outline-text-2" id="text-org5ec37bd">
</div>
</section>
<section id="slide-org833c485">
<h3 id="org833c485">Non-recursive Types</h3>
<p>
For a type &Tau;  with  constructors <i>A</i>, <i>B</i>, <i>C</i>, &#x2026; using types a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, &hellip;
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">T</span> a1 a2 a3 a4
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">A</span> a1 a2
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">B</span> a2 a3
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">C</span> a4
</pre>
</div>
</section>
<section id="slide-org2d94803">
<h5 id="org2d94803">Convert the Constructors to functions</h5>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">T</span> a1 a2 a3 a4
  <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">A</span> a1 a2
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">B</span> a2 a3
  <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">C</span> a4
</pre>
</div>

<ul>
<li><i>A</i> &equiv;  &lambda; a<sub>1</sub> a<sub>2</sub> . &lambda;  f<sub>1</sub> f<sub>2</sub> f<sub>3</sub> . f<sub>1</sub> a<sub>1</sub> a<sub>2</sub></li>
<li><i>B</i> &equiv;  &lambda; a<sub>2</sub> a<sub>3</sub> . &lambda; f<sub>1</sub> f<sub>2</sub> f<sub>3</sub> . f<sub>2</sub> a<sub>2</sub> a<sub>3</sub></li>
<li><i>C</i> &equiv;  &lambda; a<sub>4</sub> . &lambda; f<sub>1</sub> f<sub>2</sub> f<sub>3</sub> . f<sub>3</sub> a<sub>4</sub></li>

</ul>
</section>
<section id="slide-org223a259">
<h5 id="org223a259">A function taking a <i>&Tau;</i></h5>
<p>
Defined by pattern matching:
</p>
<ul>
<li>f (A x y) = body<sub>A</sub></li>
<li>f (B y z) = body<sub>B</sub></li>
<li>f (C w)   = body<sub>C</sub></li>

</ul>
</section>
<section id="slide-org1617ac3">
<h5 id="org1617ac3">Encode the function</h5>
<p>
<i>f</i>  &equiv; &lambda; t . t (&lambda; a<sub>1</sub> a<sub>2</sub> . body<sub>A</sub>) (&lambda; a<sub>2</sub> a<sub>3</sub> . body<sub>B</sub>) (&lambda; a<sub>4</sub> . body<sub>C</sub>)
</p>

<p>
Where <i>t</i> is the result of one of the encoded constructors, such as
</p>

<p>
<i>A</i> &equiv;  &lambda; a<sub>1</sub> a<sub>2</sub> . &lambda;  f<sub>1</sub> f<sub>2</sub> f<sub>3</sub> . f<sub>1</sub> a<sub>1</sub> a<sub>2</sub>
</p>

<p>
A &Tau; is encoded as a function that takes functions for each of the constructors.
</p>

<p>
It dispatches to the function that corresponds to the constructor used.
</p>

<p>
This is how <i>Pattern Matching</i> works.
</p>
</section>
<section id="slide-org7ed20ec">
<h3 id="org7ed20ec">Church Encoding for Recursive Types</h3>
<p>
A data type &Tau; with :
</p>
<ul>
<li>constructors <i>C<sub>1</sub></i> &#x2026; <i>C<sub>k</sub></i>,</li>
<li>where and the <i>arity</i> of the <i>i<sup>th</sup></i> constructor is \(ar(i)\),</li>
<li>and let \(\vec{C}\)  be a vector of all the constructors.</li>

</ul>

<p>
C<sub>i</sub> &equiv; &lambda; x<sub>1</sub> &hellip; x<sub>ar(i)</sub> . &lambda; c<sub>1</sub> &hellip; c<sub>k</sub> . c<sub>i</sub> (x<sub>1</sub> \(\vec{C}\)) &hellip; (x<sub>ar(i)</sub> \(\vec{C}\))
</p>
</section>
<section id="slide-org2aa14ff">
<h3 id="org2aa14ff">Scott Encoding for Recursive Types</h3>
<p>
A data type &Tau; with:
</p>
<ul>
<li>constructors <i>C<sub>1</sub></i> &#x2026; <i>C<sub>k</sub></i>,</li>
<li><p>
where and the <i>arity</i> of the <i>i<sup>th</sup></i> constructor is \(ar(i)\).
</p>

<p>
C<sub>i</sub> &equiv; &lambda; x<sub>1</sub> &hellip; x<sub>ar(i)</sub> . &lambda; c<sub>1</sub> &hellip; c<sub>k</sub> . c<sub>i</sub> x<sub>1</sub>  &hellip; x<sub>ar(i)</sub>
</p>

<p>
Recursive types are basically identical in the Scott encoding.
</p>
<aside class="notes">
<p>

</p>

</aside></li>

</ul>
</section>
</section>
<section>
<section id="slide-org95c6d35">
<h2 id="org95c6d35">Connections</h2>
<dl>
<dt>Folds</dt><dd>Church and Scott encodings of products are just <i>foldr</i>.</dd>
<dt>Catamorphisms</dt><dd>Folds for Sum types.</dd>
<dt>Visitor</dt><dd>The "Gang of Four" Vistor is the implementation of pattern matching.</dd>
<dt>Continuation Passing</dt><dd>All of the encodings take continuations for what to do. Moreover, Senders are an automation of Continuation Passing Style.</dd>

</dl>
</section>
</section>
<section>
<section id="slide-org445eae2">
<h2 id="org445eae2">Data and Codata</h2>
<p>
We can also define a type not in terms of how it is constructed but in terms of how it is deconstructed, or consumed.
</p>

<p>
For a type like <i>Pair</i> we become concerned with <i>fst</i> and <i>snd</i> which deconstruct in to the components, rather than <i>Pair a b</i>. For simple types the perspectives are equally expressive.
</p>

<p>
For infinite types, the codata deconstructor perspective can be more expressive, and also analytically tractable.
</p>

<p>
Codata is "new" research from the 21st Century.
</p>
</section>
<section id="slide-org7683571">
<h3 id="org7683571">Construction vs Observation</h3>
<blockquote>
<p>
[S]witching focus from the way values are built (i.e. introduced)to the way they are used (i.e. eliminated).
</p>
</blockquote>
<p>
Paul Downen, <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2020/01/CoDataInAction.pdf">Codata in Action</a>
</p>
<aside class="notes">
<p>

</p>

</aside>
</section>
<section id="slide-org80722af">
<h3 id="org80722af">State, Behavior, Identity</h3>
<div class="outline-text-3" id="text-org80722af">
</div>
<ul class="org-ul">
<li><a id="orgbb21380"></a>The hallmarks of objects in OOP are entities with<br />
<ul>
<li>State</li>
<li>Behavior</li>
<li>Identity</li>

</ul>

<p>
Objects change over time, do things, and are distinct from other instances.
</p>

<p>
Very much unlike values.
</p>
</li>
</ul>
</section>
<section id="slide-org9d59902">
<h4 id="org9d59902">References</h4>
<p>
References can not be just constructed independently.
</p>

<p>
References must be <i>observed</i> and might change independently.
</p>

<p>
References are more like codata than data.
</p>

<p>
In particular this explains why a reference member in a <code>struct</code> is so problematic.
</p>
</section>
</section>
<section>
<section id="slide-org7aa1d39">
<h2 id="org7aa1d39">Streams</h2>
<p>
Streams are an archetypical codata type.
</p>

<p>
The only operation we have on a Stream is to deconstruct it into a value and a Stream.
</p>
<ul>
<li>Always infinite</li>
<li>No empty stream - non-constructable</li>
<li>Defined by observation APIs</li>

</ul>
</section>
<section id="slide-orge980eee">
<h3 id="orge980eee">Definitions</h3>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Stream</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Stream</span>
  <span class="org-rainbow-delimiters-depth-1">{</span> head <span class="org-haskell-operator">::</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">()</span></span> <span class="org-haskell-operator">-&gt;</span> a
  , tail <span class="org-haskell-operator">::</span> <span class="org-haskell-constructor"><span class="org-rainbow-delimiters-depth-2">()</span></span> <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Stream</span> a
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
<i>head</i> and <i>tail</i> are functions in this definition so it can be <i>strict</i>.
</p>

<p>
We can't make a Stream, but if we have one can split it into the head element and the rest of the Stream.
</p>

<p>
This is an <i>Abstract</i> Data Type.
</p>
</section>
<section id="slide-orge85a369">
<h3 id="orge85a369">Codata extension</h3>
<div class="org-src-container">

<pre class="src src-haskell"><span class="org-haskell-definition">codata</span> <span class="org-haskell-constructor">Stream</span> a <span class="org-haskell-keyword">where</span>
  <span class="org-rainbow-delimiters-depth-1">{</span> head <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Stream</span> a <span class="org-haskell-operator">-&gt;</span> a
  , tail <span class="org-haskell-operator">::</span> <span class="org-haskell-type">Stream</span> a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Stream</span> a
  <span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</section>
<section id="slide-org612b19d">
<h3 id="org612b19d">Encoding Codata</h3>
<p>
We encode the observers, the <i>deconstructors</i>, or <i>eliminators</i>, instead of the <i>constructors</i>.
</p>

<p>
Those become the elements of the <i>Visitor</i> interface.
</p>

<p>
<i>head</i> = &lambda; h s . h s.head()
<i>tail</i> = &lambda; t s . t s.head()
</p>
</section>
</section>
<section>
<section id="slide-orge85d28b">
<h2 id="orge85d28b">Implementing Senders</h2>
<div class="outline-text-2" id="text-orge85d28b">
</div>
</section>
<section id="slide-org782db7f">
<h3 id="org782db7f">What's a Sender</h3>
<p>
A description of async work.
</p>

<p>
Senders "deliver" or "send" their result to a receiver.
</p>
</section>
<section id="slide-org5071bf9">
<h4 id="org5071bf9">Completion Signatures</h4>
<p>
They must advertise the signatures they may call on the reciever channels:
</p>
<ul>
<li>set_value</li>
<li>set_error</li>
<li>set_stopped</li>

</ul>
</section>
<section id="slide-orgad9df9b">
<h4 id="orgad9df9b">APIs to provide hooks for</h4>
<dl>
<dt>execution​::​get_completion_signatures</dt><dd>Can the reciever handle what the sender wants to deliver?</dd>
<dt>execution​::​connect</dt><dd>Make the connection between the sender and the continuation the results are delivered throuhg.</dd>

</dl>
</section>
<section id="slide-orgae24d8d">
<h3 id="orgae24d8d">Out of the Box</h3>
<div class="outline-text-3" id="text-orgae24d8d">
</div>
</section>
<section id="slide-org2a8dc25">
<h4 id="org2a8dc25">Sender Factories</h4>
<dl>
<dt><code>execution::just</code></dt><dd>Lift a value into a sender.</dd>
<dt><code>execution::read_env</code></dt><dd>Read from the <i>Environment</i> and deliver that value.</dd>
<dt><code>execution::schedule</code></dt><dd>Empty start of a work graph.</dd>

</dl>
</section>
<section id="slide-org1b53360">
<h4 id="org1b53360">Sender Adapters</h4>
<dl>
<dt><code>execution::then</code></dt><dd><i>map</i>, <i>transform</i>, <i>fmap</i>, etc &#x2013; the Functor interface.</dd>
<dt><code>execution::let_value</code></dt><dd><i>bind</i>, <i>and_then</i>, etc &#x2013; the Monad interface.</dd>
<dt><code>execution::on</code></dt><dd>Switch scheduler.</dd>
<dt><code>execution::when_all</code></dt><dd>Join many senders.</dd>

</dl>

<p>
The adapters <code>then</code> and <code>let_value</code> are necessary and sufficient.
</p>

<p>
Possibly not the most efficient.
</p>
</section>
<section id="slide-orgcb9e026">
<h4 id="orgcb9e026">Senders can be user code</h4>
<p>
Currently "expert-friendly."
</p>

<p>
Not intended to be "expert only."
</p>
</section>
<section id="slide-org7d466f2">
<h3 id="org7d466f2">Code Examples</h3>
<p>
Senders for:
</p>
<ul>
<li>Either</li>
<li>Pair</li>
<li><p>
Stream
</p>

<p>
[Switch to IDE and tests]
</p></li>

</ul>
</section>
</section>
<section>
<section id="slide-orgb5f2fc5">
<h2 id="orgb5f2fc5">Questions?</h2>
<p>
Remember a question starts with:
</p>

<ul>
<li class="fragment current-visible">who</li>
<li class="fragment current-visible">what</li>
<li class="fragment current-visible">when</li>
<li class="fragment current-visible">where</li>
<li class="fragment current-visible">how</li>
<li class="fragment current-visible">why</li>

</ul>

</section>
<section>
<h2>Questions?</h2>
<p>
or
</p>
<dl>
<dt>A propositional statement</dt><dd>a statement that has a truth value, either true or false, but not both.</dd>

</dl>

</section>
<section>
<h2>Questions?</h2>
<p>
and goes up at the end.
</p>

</section>
<section>
<h2>Questions?</h2>
<blockquote>
<p>
"More of a comment than a question &#x2026;"
</p>
</blockquote>
<p>
Is a propositional statement, but hold them for a moment.
</p>
</section>
</section>
<section>
<section id="slide-org53c25ab">
<h2 id="org53c25ab">Comments?</h2>

</section>
</section>
<section>
<section id="slide-orgcd7d9e5">
<h2 id="orgcd7d9e5">Thank You!</h2>

</section>
</section>
<section>
<section id="slide-org26241f4" data-visibility="hidden">
<h2 id="org26241f4">Bibliography</h2>
<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>“5B: Computational Objects | Structure and Interpretation of Computer Programs | Electrical Engineering and Computer Science | Mit Opencourseware.” n.d. <a href="https://ocw.mit.edu/courses/6-001-structure-and-interpretation-of-computer-programs-spring-2005/resources/5b-computational-objects/">https://ocw.mit.edu/courses/6-001-structure-and-interpretation-of-computer-programs-spring-2005/resources/5b-computational-objects/</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_2"></a>Downen, Paul, Zachary Sullivan, Zena M. Ariola, and Simon Peyton Jones. 2019. “Codata in Action.” In <i>Programming Languages and Systems - 28th European Symposium on Programming, ESOP 2019, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2019, Prague, Czech Republic, April 6-11, 2019, Proceedings</i>, edited by Lu\’ıs Caires, 11423:119–46. Lecture Notes in Computer Science. Springer. <a href="https://doi.org/10.1007/978-3-030-17184-1\_5">https://doi.org/10.1007/978-3-030-17184-1\_5</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_3"></a>Geuvers, Herman. 2014. “The Church-Scott Representation of Inductive and Coinductive Data in (Typed) $\Lambda$ Calculus.”</div>
  <div class="csl-entry"><a id="citeproc_bib_item_4"></a>Niebler, Eric, Michał Dominiak, Georgy Evtushenko, Lewis Baker, Lucian Radu Teodorescu, Lee Howes, Kirk Shoop, Michael Garland, and Bryce Adelstein Lelbach. 2024. “P2300R10: `Std:Execution`.” https://wg21.link/p2300r10; WG21.</div>
</div>
</section>
</section>
<section>
<section id="slide-org258e635">
<h2 id="org258e635">Code Test</h2>
<div class="org-src-container">

<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{</span>
    <span class="org-constant">std</span>::cout &lt;&lt; <span class="org-string">"hello, world\n"</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</section>
</section>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/math/math.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/markdown/markdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/notes/notes.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/search/search.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 1600,
height: 900,

transition: 'fade',
transitionSpeed: 'default',
showNotes: window.location.search.match( /print-pdf/gi ) ? 'separate-page' : false,

// Plugins with reveal.js 4.x
plugins: [ RevealMath, RevealMarkdown, RevealNotes, RevealSearch, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
